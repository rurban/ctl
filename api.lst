ctl/algorithm.h: find_if (A *self, int _match(T *))
ctl/algorithm.h: find_if_not (A *self, int _match(T *))
ctl/algorithm.h: all_of (A *self, int _match(T *))
ctl/algorithm.h: any_of (A *self, int _match(T *))
ctl/algorithm.h: none_of (A *self, int _match(T *))
ctl/algorithm.h: find_range (I *range, T value)
ctl/algorithm.h: find_if_range (I *range, int _match(T *))
ctl/algorithm.h: find_if_not_range (I *range, int _match(T *))
ctl/algorithm.h: all_of_range (I *range, int _match(T *))
ctl/algorithm.h: none_of_range (I *range, int _match(T *))
ctl/algorithm.h: any_of_range (I *range, int _match(T *))
ctl/algorithm.h: inserter (A *self, T value)
ctl/algorithm.h: copy_range (GI *range, A *out)
ctl/algorithm.h: _found (A *a, T *ref)
ctl/algorithm.h: union_range (I *r1, GI *r2)
ctl/algorithm.h: union (A *a, A *b)
ctl/algorithm.h: intersection_range (I *r1, GI *r2)
ctl/algorithm.h: intersection (A *a, A *b)
ctl/algorithm.h: difference_range (I *r1, GI *r2)
ctl/algorithm.h: symmetric_difference_range (I *r1, GI *r2)
ctl/algorithm.h: difference (A *a, A *b)
ctl/algorithm.h: symmetric_difference (A *a, A *b)
ctl/algorithm.h: includes_range (I *r1, GI *r2)
ctl/algorithm.h: includes (A *a, A *b)
ctl/algorithm.h: is_sorted (I *range)
ctl/algorithm.h: is_sorted_until (I *first, I *last)
ctl/algorithm.h: is_sorted (I *range)
ctl/algorithm.h: is_sorted_until (I *first, I *last)
ctl/algorithm.h: is_sorted_until (I *first, I *last)
ctl/algorithm.h: is_sorted (I *range)
ctl/algorithm.h: generate (A *self, T _gen(void))
ctl/algorithm.h: generate_range (I *range, T _gen(void))
ctl/algorithm.h: transform (A *self, T _unop(T *))
ctl/algorithm.h: transform_it (A *self, I *pos, T _binop(T *, T *))
ctl/algorithm.h: generate_n (A *self, size_t count, T _gen(void))
ctl/algorithm.h: generate_n_range (I *first, size_t count, T _gen(void))
ctl/algorithm.h: transform_range (I *range, I dest, T _unop(T *))
ctl/algorithm.h: transform_it_range (I *range, I *pos, I dest, T _binop(T *, T *))
ctl/algorithm.h: shuffle (A *self)
ctl/algorithm.h: shuffle_range (I *range)
ctl/algorithm.h: merge_range (I *r1, GI *r2)
ctl/algorithm.h: merge (A *a, A *b)
ctl/algorithm.h: inplace_merge (I *first, I *middle, I *last)
ctl/algorithm.h: copy_if_range (I *range, int _match(T*))
ctl/algorithm.h: copy_if (A *self, int _match(T*))
ctl/algorithm.h: count_range (I *range, T value)
ctl/algorithm.h: count (A *self, T value)
ctl/algorithm.h: mismatch (I *range1, GI *range2)
ctl/algorithm.h: lexicographical_compare (I *range1, GI *range2)
ctl/algorithm.h: count_if_range (I *range, int _match(T *))
ctl/algorithm.h: count_if (A *self, int _match(T *))
ctl/algorithm.h: find_first_of_range (I *range1, GI *range2)
ctl/algorithm.h: find_first_of (A *self, GI *range2)
ctl/algorithm.h: search_range (I *range1, GI *range2)
ctl/algorithm.h: search (A *self, I *subseq)
ctl/algorithm.h: find_end_range (I *range1, GI *range2)
ctl/algorithm.h: find_end (A *self, I *s_range)
ctl/algorithm.h: search_n_range (I *range, size_t count, T value)
ctl/algorithm.h: search_n (A *self, size_t count, T value)
ctl/algorithm.h: adjacent_find_range (I *range)
ctl/algorithm.h: adjacent_find (A *self)
ctl/algorithm.h: equal_value (I *range, T value)
ctl/algorithm.h: equal_range (I *range1, GI *range2)
ctl/algorithm.h: lower_bound_range (I *range, T value)
ctl/algorithm.h: upper_bound_range (I *range, T value)
ctl/algorithm.h: lower_bound (A *self, T value)
ctl/algorithm.h: upper_bound (A *self, T value)
ctl/algorithm.h: binary_search_range (I *range, T value)
ctl/algorithm.h: binary_search (A *self, T value)
ctl/algorithm.h: equal_range (A *self, T key, I *lower_bound, I *upper_bound)
ctl/algorithm.h: unique_range (I *range)
ctl/algorithm.h: unique (A *self)
ctl/algorithm.h: reverse_range (I *first)
ctl/algorithm.h: reverse (A *a)
ctl/array.h: size (A *self)
ctl/array.h: empty (A *self)
ctl/array.h: max_size (void)
ctl/array.h: at (A *self, size_t index)
ctl/array.h: get (A *self, size_t index)
ctl/array.h: front (A *self)
ctl/array.h: back (A *self)
ctl/array.h: begin (A *self)
ctl/array.h: end (A *self)
ctl/array.h: init (void)
ctl/array.h: init_from (A *copy)
ctl/array.h: zero (T *ref)
ctl/array.h: set (A *self, size_t index, T value)
ctl/array.h: fill (A *self, T value)
ctl/array.h: fill_range (I *range, T value)
ctl/array.h: fill_zero (I *range)
ctl/array.h: fill_n (A *self, size_t n, T value)
ctl/array.h: clear (A *self)
ctl/array.h: free (A *self)
ctl/array.h: assign (A *self, size_t count, T value)
ctl/array.h: assign_range (A *self, T *from, T *last)
ctl/array.h: assign_generic (A *self, GI *range)
ctl/array.h: data (A *self)
ctl/array.h: swap (A *self, A *other)
ctl/array.h: _ranged_sort (A *self, size_t a, size_t b, int _compare(T *, T *))
ctl/array.h: sort (A *self)
ctl/array.h: copy (A *self)
ctl/array.h: find (A *self, T key)
ctl/array.h: transform_it (A *self, I *pos, T _binop(T *, T *))
ctl/array.h: copy_if_range (I *range, int _match(T*))
ctl/array.h: copy_if (A *self, int _match(T*))
ctl/array.h: copy_range (I *it, GI *from)
ctl/array.h: intersection_range (I *r1, GI *r2)
ctl/array.h: difference_range (I *r1, I *r2)
ctl/array.h: symmetric_difference_range (I *r1, GI *r2)
ctl/deque.h: first (A *self)
ctl/deque.h: last (A *self)
ctl/deque.h: at (A *self, size_t index)
ctl/deque.h: shrink_to_fit (A *self)
ctl/deque.h: front (A *self)
ctl/deque.h: back (A *self)
ctl/deque.h: begin (A *self)
ctl/deque.h: end (A *self)
ctl/deque.h: init_from (A *copy)
ctl/deque.h: set (A *self, size_t index, T value)
ctl/deque.h: alloc (A *self, size_t capacity, size_t shift_from)
ctl/deque.h: init (void)
ctl/deque.h: push_front (A *self, T value)
ctl/deque.h: pop_front (A *self)
ctl/deque.h: push_back (A *self, T value)
ctl/deque.h: pop_back (A *self)
ctl/deque.h: erase_index (A *self, size_t index)
ctl/deque.h: erase (I *pos)
ctl/deque.h: insert_index (A *self, size_t index, T value)
ctl/deque.h: insert (I *pos, T value)
ctl/deque.h: clear (A *self)
ctl/deque.h: free (A *self)
ctl/deque.h: copy (A *self)
ctl/deque.h: resize (A *self, size_t size, T value)
ctl/deque.h: erase_range (I *range)
ctl/deque.h: emplace (I *pos, T *value)
ctl/deque.h: emplace_front (A *self, T *value)
ctl/deque.h: emplace_back (A *self, T *value)
ctl/deque.h: insert_range (I *pos, I *range)
ctl/deque.h: insert_count (I *pos, size_t count, T value)
ctl/deque.h: assign (A *self, size_t size, T value)
ctl/deque.h: assign_generic (A *self, GI *range)
ctl/deque.h: _ranged_sort (A *self, size_t from, size_t to, int _compare(T *, T *))
ctl/deque.h: sort (A *self)
ctl/deque.h: sort_range (A *self, size_t from, size_t to)
ctl/deque.h: remove_if (A *self, int (*_match)(T *))
ctl/deque.h: erase_if (A *self, int (*_match)(T *))
ctl/deque.h: find (A *self, T key)
ctl/deque.h: swap (A *self, A *other)
ctl/deque.h: move_range (I *range, A *out)
ctl/deque.h: insert_generic (I *pos, GI *range)
ctl/forward_list.h: tail (A *self)
ctl/forward_list.h: empty (A *self)
ctl/forward_list.h: front (A *self)
ctl/forward_list.h: begin (A *self)
ctl/forward_list.h: end (A *self)
ctl/forward_list.h: size (A *self)
ctl/forward_list.h: init (void)
ctl/forward_list.h: init_from (A *copy)
ctl/forward_list.h: disconnect (A *self, B *node)
ctl/forward_list.h: connect_before (A *self, B *position, B *node)
ctl/forward_list.h: transfer_before (A *self, A *other, B *position, B *node)
ctl/forward_list.h: push_front (A *self, T value)
ctl/forward_list.h: erase_after (A *self, B *node)
ctl/forward_list.h: erase_range (I* range)
ctl/forward_list.h: pop_front (A *self)
ctl/forward_list.h: insert_after (I *iter, T value)
ctl/forward_list.h: insert_range (I *iter, GI* range)
ctl/forward_list.h: insert_generic (I *iter, GI* range)
ctl/forward_list.h: clear (A *self)
ctl/forward_list.h: free (A *self)
ctl/forward_list.h: has_cycle (A *self)
ctl/forward_list.h: length (A *self)
ctl/forward_list.h: swap (A *self, A *other)
ctl/forward_list.h: reverse_range (I *range)
ctl/forward_list.h: reverse (A *self)
ctl/forward_list.h: copy (A *self)
ctl/forward_list.h: assign (A *self, size_t size, T value)
ctl/forward_list.h: assign_generic (A *self, GI *range)
ctl/forward_list.h: remove (A *self, T value)
ctl/forward_list.h: erase (A *self, void *vvalue)
ctl/forward_list.h: remove_if (A *self, int _match(T *))
ctl/forward_list.h: erase_if (A *self, int _match(T *))
ctl/forward_list.h: splice_after (A *self, B *position, A *other)
ctl/forward_list.h: connect_after (A *self, B *position, B *node)
ctl/forward_list.h: transfer_after (A *self, A *other, B *position, B *node)
ctl/forward_list.h: broken_merge (A *self, A *other)
ctl/forward_list.h: equal (A *self, A *other)
ctl/forward_list.h: fast_sort (A *self)
ctl/forward_list.h: merge_range (I *r1, GI *r2)
ctl/forward_list.h: merge (A *self, A *other)
ctl/forward_list.h: sort (A *self)
ctl/forward_list.h: stable_sort (A *self)
ctl/forward_list.h: sort_range (I *range)
ctl/forward_list.h: unique (A *self)
ctl/forward_list.h: find (A *self, T key)
ctl/forward_list.h: copy_range (GI *range, A *out)
ctl/forward_list.h: copy_front_range (GI *range, A *out)
ctl/forward_list.h: move_range (I *range, A *out)
ctl/forward_list.h: unique_range (I *range)
ctl/forward_list.h: union_range (I *r1, GI *r2)
ctl/forward_list.h: intersection_range (I *r1, GI *r2)
ctl/forward_list.h: symmetric_difference_range (I *r1, GI *r2)
ctl/forward_list.h: difference_range (I *r1, GI *r2)
ctl/forward_list.h: difference (A *a, A *b)
ctl/forward_list.h: union (A *a, A *b)
ctl/forward_list.h: intersection (A *a, A *b)
ctl/forward_list.h: symmetric_difference (A *a, A *b)
ctl/forward_list.h: iter_swap (I *iter1, I *iter2)
ctl/forward_list.h: shuffle (A *self)
ctl/list.h: front (A *self)
ctl/list.h: back (A *self)
ctl/list.h: begin (A *self)
ctl/list.h: end (A *self)
ctl/list.h: disconnect (A *self, B *node)
ctl/list.h: init (void)
ctl/list.h: init_from (A *copy)
ctl/list.h: connect_before (A *self, B *position, B *node)
ctl/list.h: push_front (A *self, T value)
ctl/list.h: transfer_before (A *self, A *other, B *position, B *node)
ctl/list.h: erase_node (A *self, B *node)
ctl/list.h: erase (I *it)
ctl/list.h: pop_back (A *self)
ctl/list.h: pop_front (A *self)
ctl/list.h: insert (I *pos, T value)
ctl/list.h: clear (A *self)
ctl/list.h: free (A *self)
ctl/list.h: connect_after (A *self, B *position, B *node)
ctl/list.h: push_back (A *self, T value)
ctl/list.h: resize (A *self, size_t size, T value)
ctl/list.h: copy (A *self)
ctl/list.h: assign (A *self, size_t size, T value)
ctl/list.h: assign_generic (A *self, GI *range)
ctl/list.h: reverse (A *self)
ctl/list.h: remove (A *self, T value)
ctl/list.h: emplace (I *pos, T *value)
ctl/list.h: emplace_front (A *self, T *value)
ctl/list.h: emplace_back (A *self, T *value)
ctl/list.h: insert_count (I *pos, size_t count, T value)
ctl/list.h: insert_range (I *pos, I *range)
ctl/list.h: insert_generic (I *pos, GI *range)
ctl/list.h: remove_if (A *self, int _match(T *))
ctl/list.h: erase_if (A *self, int _match(T *))
ctl/list.h: erase_range (I *range)
ctl/list.h: erase_generic (A* self, GI *range)
ctl/list.h: swap (A *self, A *other)
ctl/list.h: splice (I *pos, A *other)
ctl/list.h: splice_it (I *pos, I *first2)
ctl/list.h: splice_range (I *pos, I *range2)
ctl/list.h: transfer_after (A *self, A *other, B *position, B *node)
ctl/list.h: iter_swap (I *iter1, I *iter2)
ctl/list.h: move_range (I *range, A *out)
ctl/list.h: merge (A *self, A *other)
ctl/list.h: sort (A *self)
ctl/list.h: unique_range (I *range)
ctl/list.h: unique (A *self)
ctl/list.h: find (A *self, T key)
ctl/list.h: shuffle (A *self)
ctl/list.h: verify (A *self)
ctl/map.h: insert_or_assign (A *self, T key)
ctl/map.h: insert_or_assign_found (A *self, T key, int *foundp)
ctl/numeric.h: iota (A *self, T value)
ctl/numeric.h: iota_range (I *range, T value)
ctl/priority_queue.h: init (int _compare(T *, T *))
ctl/priority_queue.h: up (A *self, size_t n)
ctl/priority_queue.h: down (A *self, size_t n)
ctl/priority_queue.h: push (A *self, T value)
ctl/priority_queue.h: pop (A *self)
ctl/priority_queue.h: emplace (A *self, T *value)
ctl/set.h: first (A *self)
ctl/set.h: begin (A *self)
ctl/set.h: end (A *self)
ctl/set.h: last (A *self)
ctl/set.h: init (int _compare(T *, T *))
ctl/set.h: init_from (A *copy)
ctl/set.h: free_node (A *self, B *node)
ctl/set.h: find_node (A *self, T key)
ctl/set.h: find (A *self, T key)
ctl/set.h: find_range (I *range, T key)
ctl/set.h: count (A *self, T key)
ctl/set.h: contains (A *self, T key)
ctl/set.h: verify (A *self)
ctl/set.h: rotate_l (A *self, B *node)
ctl/set.h: rotate_r (A *self, B *node)
ctl/set.h: insert (A *self, T key)
ctl/set.h: insert_found (A *self, T key, int *foundp)
ctl/set.h: insert_1 (A *self, B *node)
ctl/set.h: insert_2 (A *self, B *node)
ctl/set.h: insert_3 (A *self, B *node)
ctl/set.h: insert_4 (A *self, B *node)
ctl/set.h: insert_5 (A *self, B *node)
ctl/set.h: erase_node (A *self, B *node)
ctl/set.h: erase_it (I *it)
ctl/set.h: erase_range (I *range)
ctl/set.h: erase (A *self, T key)
ctl/set.h: erase_1 (A *self, B *node)
ctl/set.h: erase_2 (A *self, B *node)
ctl/set.h: erase_3 (A *self, B *node)
ctl/set.h: erase_4 (A *self, B *node)
ctl/set.h: erase_5 (A *self, B *node)
ctl/set.h: erase_6 (A *self, B *node)
ctl/set.h: clear (A *self)
ctl/set.h: free (A *self)
ctl/set.h: copy (A *self)
ctl/set.h: swap (A *self, A *other)
ctl/set.h: remove_if (A *self, int (*_match)(T *))
ctl/set.h: erase_if (A *self, int (*_match)(T *))
ctl/set.h: insert_generic (A* self, GI *range)
ctl/set.h: erase_generic (A* self, GI *range)
ctl/set.h: intersection (A *a, A *b)
ctl/set.h: intersection_range (I *r1, GI *r2)
ctl/set.h: union (A *a, A *b)
ctl/set.h: union_range (I *r1, GI *r2)
ctl/set.h: difference (A *a, A *b)
ctl/set.h: symmetric_difference (A *a, A *b)
ctl/set.h: _inserter (A *self, B *node, T *value)
ctl/set.h: insert_range (A *self, I *range)
ctl/set.h: generate (A *self, T _gen(void))
ctl/set.h: generate_range (I *range, T _gen(void))
ctl/set.h: generate_n (A *self, size_t count, T _gen(void))
ctl/set.h: generate_n_range (I *range, size_t count, T _gen(void))
ctl/set.h: transform (A *self, T _unop(T *))
ctl/set.h: transform_it (A *self, I *pos, T _binop(T *, T *))
ctl/set.h: transform_range (I *range1, I dest, T _unop(T *))
ctl/set.h: transform_it_range (I *range1, I *pos, I dest, T _binop(T *, T *))
ctl/set.h: find_first_of_range (I *range1, GI *range2)
ctl/sorted_vector.h: emplace (I *pos, T *value)
ctl/sorted_vector.h: assign_range (A *self, T *from, T *last)
ctl/sorted_vector.h: assign_generic (A *self, GI *range)
ctl/sorted_vector.h: insert_index (A *self, size_t index, T value)
ctl/sorted_vector.h: erase_index (A *self, size_t index)
ctl/sorted_vector.h: erase_range (I *range)
ctl/sorted_vector.h: insert (A *self, T value)
ctl/sorted_vector.h: insert_count (A *self, size_t count, T value)
ctl/sorted_vector.h: insert_range (A *self, I *range2)
ctl/sorted_vector.h: erase (A* self, T value)
ctl/sorted_vector.h: insert_generic (A* self, GI *range)
ctl/sorted_vector.h: _ranged_sort (A *self, size_t a, size_t b, int _compare(T *, T *))
ctl/sorted_vector.h: copy (A *self)
ctl/sorted_vector.h: find (A *self, T key)
ctl/sorted_vector.h: move_range (I *range, A *out)
ctl/unordered_map.h: insert_or_assign (A *self, T value)
ctl/unordered_map.h: insert_or_assign_found (A *self, T value, int *foundp)
ctl/unordered_set.h: bucket_count (A *self)
ctl/unordered_set.h: _equal (A *self, T *a, T *b)
ctl/unordered_set.h: inserter (A *self, T value)
ctl/unordered_set.h: begin (A *self)
ctl/unordered_set.h: end (A *self)
ctl/unordered_set.h: __next_prime (size_t number)
ctl/unordered_set.h: __next_power2 (uint32_t n)
ctl/unordered_set.h: _cached_bucket (A *self, B *node)
ctl/unordered_set.h: _bucket_hash (A *self, size_t hash)
ctl/unordered_set.h: _bucket (A *self, T value)
ctl/unordered_set.h: bucket (A *self, T value)
ctl/unordered_set.h: bucket_size (A *self, size_t index)
ctl/unordered_set.h: _free_node (A *self, B *n)
ctl/unordered_set.h: max_load_factor (A *self, float f)
ctl/unordered_set.h: max_bucket_count (A *self)
ctl/unordered_set.h: load_factor (A *self)
ctl/unordered_set.h: _reserve (A *self, const size_t new_size)
ctl/unordered_set.h: reserve (A *self, size_t desired_count)
ctl/unordered_set.h: init (size_t (*_hash)(T *), int (*_equal)(T *, T *))
ctl/unordered_set.h: init_from (A *copy)
ctl/unordered_set.h: rehash (A *self, size_t desired_count)
ctl/unordered_set.h: _rehash (A *self, size_t count)
ctl/unordered_set.h: find_node (A *self, T value)
ctl/unordered_set.h: find (A *self, T value)
ctl/unordered_set.h: push_cached (A *self, T *value)
ctl/unordered_set.h: _pre_insert_grow (A *self)
ctl/unordered_set.h: insert (A *self, T value)
ctl/unordered_set.h: insert_found (A *self, T value, int *foundp)
ctl/unordered_set.h: emplace (A *self, T *value)
ctl/unordered_set.h: emplace_found (A *self, T *value, int *foundp)
ctl/unordered_set.h: emplace_hint (I *pos, T *value)
ctl/unordered_set.h: clear (A *self)
ctl/unordered_set.h: free (A *self)
ctl/unordered_set.h: count (A *self, T value)
ctl/unordered_set.h: contains (A *self, T value)
ctl/unordered_set.h: _linked_erase (A *self, B **bucket, B *n, B *prev, B *next)
ctl/unordered_set.h: erase (A *self, T value)
ctl/unordered_set.h: erase_if (A *self, int (*_match)(T *))
ctl/unordered_set.h: copy (A *self)
ctl/unordered_set.h: insert_generic (A* self, GI *range)
ctl/unordered_set.h: erase_generic (A* self, GI *range)
ctl/unordered_set.h: union (A *a, A *b)
ctl/unordered_set.h: union_range (I *r1, GI *r2)
ctl/unordered_set.h: intersection (A *a, A *b)
ctl/unordered_set.h: intersection_range (I *r1, GI *r2)
ctl/unordered_set.h: difference (A *a, A *b)
ctl/unordered_set.h: symmetric_difference (A *a, A *b)
ctl/unordered_set.h: equal (A *self, A *other)
ctl/unordered_set.h: swap (A *self, A *other)
ctl/unordered_set.h: merge_range (I *r1, GI *r2)
ctl/unordered_set.h: merge (A *self, A* other)
ctl/unordered_set.h: generate (A *self, T _gen(void))
ctl/unordered_set.h: generate_n (A *self, size_t n, T _gen(void))
ctl/unordered_set.h: transform (A *self, T _unop(T *))
ctl/vector.h: capacity (A *self)
ctl/vector.h: at (A *self, size_t index)
ctl/vector.h: front (A *self)
ctl/vector.h: back (A *self)
ctl/vector.h: begin (A *self)
ctl/vector.h: end (A *self)
ctl/vector.h: init (void)
ctl/vector.h: init_from (A *copy)
ctl/vector.h: set (A *self, size_t index, T value)
ctl/vector.h: pop_back (A *self)
ctl/vector.h: fit (A *self, size_t capacity)
ctl/vector.h: wipe (A *self, size_t n)
ctl/vector.h: clear (A *self)
ctl/vector.h: free (A *self)
ctl/vector.h: reserve (A *self, const size_t n)
ctl/vector.h: push_back (A *self, T value)
ctl/vector.h: emplace_back (A *self, T *value)
ctl/vector.h: emplace (I *pos, T *value)
ctl/vector.h: resize (A *self, size_t size, T value)
ctl/vector.h: assign (A *self, size_t count, T value)
ctl/vector.h: assign_range (A *self, T *from, T *last)
ctl/vector.h: assign_generic (A *self, GI *range)
ctl/vector.h: shrink_to_fit (A *self)
ctl/vector.h: data (A *self)
ctl/vector.h: insert_index (A *self, size_t index, T value)
ctl/vector.h: erase_index (A *self, size_t index)
ctl/vector.h: erase_range (I *range)
ctl/vector.h: insert (I *pos, T value)
ctl/vector.h: insert_count (I *pos, size_t count, T value)
ctl/vector.h: insert_range (I *pos, I *range2)
ctl/vector.h: erase (I *pos)
ctl/vector.h: insert_generic (I *pos, GI *range)
ctl/vector.h: swap (A *self, A *other)
ctl/vector.h: _ranged_sort (A *self, size_t a, size_t b, int _compare(T *, T *))
ctl/vector.h: sort (A *self)
ctl/vector.h: copy (A *self)
ctl/vector.h: remove_if (A *self, int (*_match)(T *))
ctl/vector.h: erase_if (A *self, int (*_match)(T *))
ctl/vector.h: find (A *self, T key)
ctl/vector.h: move_range (I *range, A *out)
