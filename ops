{"version":1,"ops":[{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1612959077,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0OTE4MjU3ODg="},"target":"b10332a3d4bd4d1b7d58b311451272d572c0bced1df3deb973bbf99471f54d2b","message":"So far we can only iterate over iterators with known type.\nBut the STL supports e.g. insert_range from a vector into a deque.\nOur `deque.insert_range` does `foreach_range(A, iter, first, last)`, where first and last must be of type A, not some generic type. We only need to insert *first.ref into our deque, and need to know how to ++first, regardless of the type of the iters.\nThe only way to solve this would be to add the I `ref`, `next` and `done` functions to the I struct itself.\n\n\nEither share a common vtable for all T_it, or direct generic functions as above.\n```\nstruct it_vtable {\n  void next(I*);\n  T* ref(I*);\n  int done(I*);\n}\n\nstruct I {\n  B* _node;\n  T* _ref;\n  B* _end;\n  A* container;\n  struct it_vtable vtable;\n}\n\nT_it_advance(T_it*);\nT_it_distance(T_it*, T_it*);\n\nA_union_range(I* range1, T_it* range2);\n...\n```","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1612959106,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0OTE4MjU5ODk="},"target":"b10332a3d4bd4d1b7d58b311451272d572c0bced1df3deb973bbf99471f54d2b","message":"So far we can only iterate over iterators with known type.\nBut the STL supports e.g. insert_range from a vector into a deque.\nOur `deque.insert_range` does `foreach_range(A, iter, first, last)`, where first and last must be of type A, not some generic type. We only need to insert *first.ref into our deque, and need to know how to ++first, regardless of the type of the iters.\nThe only way to solve this would be to add the I `ref`, `next` and `done` functions to the I struct itself.\n\n\nEither share a common vtable for all T_it, or direct generic functions as above, and a CTL_REF macro.\n```\nstruct it_vtable {\n  void next(I*);\n  T* ref(I*);\n  int done(I*);\n}\n\nstruct I {\n  B* _node;\n  T* _ref;\n  B* _end;\n  A* container;\n  struct it_vtable vtable;\n}\n\nT_it_advance(T_it*);\nT_it_distance(T_it*, T_it*);\n\nA_union_range(I* range1, T_it* range2);\n...\n```","files":null}]}