{"version":1,"ops":[{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610355017,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0Njg0NTM="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Add another abstract IT type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning B* nodes (list, set, uset)\n   - returning T* valuerefs directly (arrays).\n   - returning size_t index directly (deque).\n\nAlgorithms dont take I* iters, but IT elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned.\nAnd it's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nsee the `iters` branch","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610355046,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0Njg2NDk="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Add another abstract IT type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning B* nodes (list, set, uset)\n   - returning T* valuerefs directly (arrays).\n   - returning size_t index directly (deque).\n\nAlgorithms dont take I* iters, but IT elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned.\nAnd it's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nsee the https://github.com/rurban/ctl/commits/iters branch","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610355477,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0NzE4NDk="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned.\nAnd it's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nsee the https://github.com/rurban/ctl/commits/iters branch","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610355611,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0NzI5OTM="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nsee the https://github.com/rurban/ctl/commits/iters branch","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610356032,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0NzYyNzM="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nSee the https://github.com/rurban/ctl/commits/iters branch\n\n---------------------------\n\nThe 2nd idea is to slim down the expensive it.step computation.\nWe currently set 3 fields, node, next and ref, the STL only sets next.\nOnly next is needed to check for end. No need for ref, done, node and such. \nSee the perf images.","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610356106,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0NzY3NzI="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nSee the https://github.com/rurban/ctl/commits/iters branch\n\n---------------------------\n\nThe 2nd idea is to slim down the expensive it.step computation.\nWe currently set 3 fields, node, next and ref, the STL only sets next.\nOnly next is needed to check for end. No need for ref, done, node and such. \nSee the perf images.\nit.ref can be a macro. node is currently needed for some cases, get rid of them.","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610356228,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc0Nzc2NTg="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nSee the https://github.com/rurban/ctl/commits/iters branch\n\n---------------------------\n\nThe 2nd idea is to slim down the expensive it.step computation.\nWe currently set 3 fields, node, next and ref, the STL only needs node.\nOnly next is needed to check for end. No need for ref, done, next, begin, container and such. \nSee the perf images.\n\nit.ref can be a macro. node is the iter value, but next can be computed by ++ (from B*, T* or size_t)","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610368135,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0Nzc1NjYxNDM="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nSee the https://github.com/rurban/ctl/commits/iters branch\n\n---------------------------\n\nThe 2nd idea is to slim down the expensive it.step computation.\nWe currently set 3 fields, node, next and ref, the STL only needs node.\nOnly next is needed to check for end. No need for ref, done, next, begin, container and such. \nSee the perf images.\n\nit.ref can be a macro. node is the iter value, but next can be computed by ++ (from B*, T* or size_t)\n\nAlso, there needs to be a `advance` method, and see the existing `iter` method to convert `IT` to `I*`, i.e. to create I* objects","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610443613,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NzgwNzQ1OTI="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Keep our `I` API for `_it`\nAdd another abstract `IT` type, which is the return type of begin(), end().\n\nAbstract IT (T* value, B* node or size_t index) and foreach_range.\nWe have three major kinds of iterators:\n   - returning `B*` nodes (list, set, uset)\n   - returning `T*` valuerefs directly (arrays).\n   - returning `size_t` index directly (deque).\n\nAlgorithms dont take `I*` iters, but `IT` elems, like for list B* first, B* last (i.e. IT first, IT last).\n\nIters (I) are useless and tricky to compute by the users, he only cares about the nodes, (or T* or size_t index for deque), which is the type returned. With `I* first, I* last`, only `I iter` would be really needed, as `I* first` contains the end info already.\nBut then we need `A* self` again, not just `I* first, I* last`.\n\nIt's the same in the STL, there they have special Iterator types, with those underlying. Not really matching our I* helper type.\n\nSee the https://github.com/rurban/ctl/commits/iters branch\n\n---------------------------\n\nThe 2nd idea is to slim down the expensive it.step computation.\nWe currently set 3 fields, node, next and ref, the STL only needs node.\nOnly next is needed to check for end. No need for ref, done, next, begin, container and such. \nSee the perf images.\n\nit.ref can be a macro. node is the iter value, but next can be computed by ++ (from B*, T* or size_t)\n\nFor uset (hashes) we need to improve iter run-time performance. Link the buckets together. Not only the chain, but also the main entries, so we don't need two states, only `next`. Get rid of the `bucket_index` state. This costs a bit on insert.\n\n--------------------------\n\nAlso, there needs to be a `advance` method, and see the existing `iter` method to convert `IT` to `I*`, i.e. to create I* objects","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610445271,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NzgwODg2NDI="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Currently we mimic libstdc++ v3 from gcc only.\nclang libc++ has different growth policies, e.g with string, vector and uset is the same currently.\n\nSo we need to detect clang's libc++ and either mimic its string growth or disable the check. It should be implementation-specific at all.","files":null},{"type":6,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610445271,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NzgwODg2NDM="},"target":"8be746678b728e87ceb9943d735f5c1ed47a477dd175e92da1d4f807bfb65183","message":"Currently we mimic libstdc++ v3 from gcc only.\nclang libc++ has different growth policies, e.g with string, vector and uset is the same currently.\n\nSo we need to detect clang's libc++ and either mimic its string growth or disable the check. It should be implementation-specific at all.\n\nclang++ and libc++ is the default CXX on macOS and FreeBSD.\nMSVC will be a different beast, and ICC had traditionally the most libc++ bugs.","files":null},{"type":5,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610443625,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDQxOTQ4NTU5MjI="},"added":["enhancement"],"removed":[]},{"type":3,"author":{"id":"67acf4ce3a9e0b675b41dc633e984435404c2f17"},"timestamp":1610648736,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc2MDM4NDYwMA==","github-url":"https://github.com/rurban/ctl/issues/1#issuecomment-760384600"},"message":"Another new idea is to embed the `it-\u003econtainer` field in `I*`, \n`I*` being just a struct of  IT + container.\n\nPublicly passed around is just IT, so that we can increment it. (B*-\u003enext, T*++, size_t++)\nThe container is just added on construction, or when it's missing.\nAnd only to omit self from the range algos.","files":null}]}